1) synchronized可以写在方法声明上，也可以使用synchronized代码块。

2) 它可以保证在任何时刻只有一个线程执行该方法或者代码块里的内容。当
线程A获取了锁，其他线程就无法获取到锁，进不去方法或者代码块中，只能
等线程A释放锁之后才可以再次获取该锁。

3) synchronized是给对象加锁，如果写在方法上就是给该方法所属的对象
加锁，也就是this对象。如果使用synchronized，那么可以指定被加锁的对
象，可以是this也可以是其他对象。

4) synchronized是加载堆内存中对象的实例上的，而不是加在引用变量上
的，如果改变了引用变量引用的对象，就会使锁失效，demo2证明。

5) 线程A获取到该对象的锁的时候，其他线程可以访问该对象的非同步方法
（没加锁的方法，或者代码块），demo3证明。

6) synchronized是可重入锁。如果两个同步方法用的是同一个对象的锁，那
么获得该锁的线程在执行方法A时可以调用方法B demo4证明。另外，子类的同
步方法也可以调用父类的同步方法，demo7证明。重复获得同一个锁会使该对象
在堆内存中记录的被锁定的次数加一.

7) 使用synchronized加锁，在线程抛出异常会释放锁，demo5证明。

8) synchronized 既保证了可见性又保证了原子性。

9) 不要使用字符串常量作为锁对象，容易产生死锁。